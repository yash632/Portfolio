<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Tech Sphere</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #111116 0%, #050505 80%, #000000 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    canvas {
      display: block;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ffff;
      font-size: 24px;
      pointer-events: none;
      transition: opacity 0.5s;
    }
  </style>
  <!-- Import Three.js and OrbitControls from CDN -->
  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
  <div id="loading">Loading 3D Engine...</div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Configuration ---
    const skills = [
      "C", "C++", "Python", "HTML", "CSS", "JS",
      "ReactJS", "Node", "Express", "Flask",
      "ML", "AI", "CV", "Data Science", "MongoDB"
    ];

    // Colors for randomizing neon effects
    const colors = [
      "#00ffff", "#00bfff", "#1e90ff", // Cyan/Blue
      "#ff00ff", "#da70d6", "#8a2be2", // Purple/Pink
      "#ffffff", "#00ffcc" // Accents
    ];

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    // Removed fog to let gradient show through or keep it minimal
    // scene.fog = new THREE.FogExp2(0x050505, 0.02); 

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = false;
    controls.enabled = true; // Allow interaction but we handle rotation manually

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const pointLight1 = new THREE.PointLight(0x00ffff, 3, 60);
    pointLight1.position.set(15, 15, 15);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xff00ff, 3, 60);
    pointLight2.position.set(-15, -15, -15);
    scene.add(pointLight2);

    // Group for the sphere elements to rotate them together
    const sphereGroup = new THREE.Group();
    scene.add(sphereGroup);

    // --- Helper: Create Text Sprites ---
    function createTextSprite(text) {
      const fontface = "Arial";
      const fontsize = 60;
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 256;

      const color = colors[Math.floor(Math.random() * colors.length)];

      context.shadowColor = color;
      context.shadowBlur = 25;
      context.fillStyle = color;
      context.font = "bold " + fontsize + "px " + fontface;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending
      });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(8, 4, 1);
      return sprite;
    }

    // --- Core Sphere Construction ---
    // --- Core Sphere Construction ---
    // 1. Inner core: Removed for full transparency as requested.
    // The wireframe handles the shape definition now.

    const wireframeGeometry = new THREE.SphereGeometry(10, 32, 32);
    const wireframeMaterial = new THREE.MeshBasicMaterial({
      color: 0x0088ff,
      wireframe: true,
      transparent: true,
      opacity: 0.1
    });
    const wireframeSphere = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
    sphereGroup.add(wireframeSphere);

    // --- Distribute Skills ---
    const vector = new THREE.Vector3();
    const phi = Math.PI * (3 - Math.sqrt(5));
    // Add more "dummy" skills or repeat to fill sphere if needed, or just use list
    for (let i = 0; i < skills.length; i++) {
      const y = 1 - (i / (skills.length - 1)) * 2;
      const radius = Math.sqrt(1 - y * y);
      const theta = phi * i;
      const x = Math.cos(theta) * radius;
      const z = Math.sin(theta) * radius;
      const sphereRadius = 12; // Radius for text
      vector.set(x, y, z).normalize().multiplyScalar(sphereRadius);
      const sprite = createTextSprite(skills[i]);
      sprite.position.copy(vector);
      sphereGroup.add(sprite);
    }

    // --- Background Particles (Stars) ---
    // Make them independent of sphereGroup to stay in background
    const bgGroup = new THREE.Group();
    scene.add(bgGroup);

    const particlesGeometry = new THREE.BufferGeometry();
    const particlesCount = 800;
    const posArray = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount * 3; i++) {
      posArray[i] = (Math.random() - 0.5) * 120; // Spread wider
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const particlesMaterial = new THREE.PointsMaterial({
      size: 0.15,
      color: 0x88ccff,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });
    const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
    bgGroup.add(particlesMesh);

    // --- Animation Loop ---
    document.getElementById('loading').style.opacity = 0;
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      // Continuous multi-axis rotation (Tumbling effect)
      // Small values to keep it readable but moving in all directions
      sphereGroup.rotation.y += 0.003;
      sphereGroup.rotation.x += 0.002;
      sphereGroup.rotation.z += 0.001;

      // Rotate background slowly in opposite direction for depth
      bgGroup.rotation.y -= 0.0005;

      // Pulse wireframe
      const time = clock.getElapsedTime();
      wireframeMaterial.opacity = 0.1 + Math.abs(Math.sin(time)) * 0.1;

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>